---
import { marked } from 'marked';
import Layout from '../../layouts/Layout.astro';
import EpisodeDetail from '../../components/EpisodeDetail.jsx';
import StickySubscribeBar from '../../components/StickySubscribeBar.jsx';

export async function getStaticPaths() {
  // 1. Fetch RSS
  const rssRes = await fetch('https://grayking-creator.github.io/openclaw-podcast/feed.xml');
  const rssText = await rssRes.text();

  // 2. Parse episodes (same helpers as podcasts.astro — inlined here)
  const getTag = (xml: string, tag: string): string => {
    // Handle CDATA
    const cdataRe = new RegExp(`<${tag}[^>]*><!\\[CDATA\\[([\\s\\S]*?)\\]\\]><\\/${tag}>`, 'i');
    const cdataM = xml.match(cdataRe);
    if (cdataM) return cdataM[1].trim();
    const plainRe = new RegExp(`<${tag}[^>]*>([\\s\\S]*?)<\\/${tag}>`, 'i');
    const plainM = xml.match(plainRe);
    return plainM ? plainM[1].trim() : '';
  };

  const getAttr = (xml: string, tag: string, attr: string): string => {
    const re = new RegExp(`<${tag}[^>]*\\s${attr}="([^"]+)"`, 'i');
    const m = xml.match(re);
    return m ? m[1] : '';
  };

  const items = rssText.match(/<item>([\s\S]*?)<\/item>/g) ?? [];

  const episodes = await Promise.all(items.map(async (item) => {
    const episodeNum = parseInt(getTag(item, 'itunes:episode') || '0');
    const slug = `episode-${episodeNum}`;
    const mdUrl = getTag(item, 'link');
    const audioUrl = getAttr(item, 'enclosure', 'url');
    const title = getTag(item, 'title').replace(/^Episode \d+:\s*/, '');
    const description = getTag(item, 'description');
    const pubDate = getTag(item, 'pubDate');
    const duration = getTag(item, 'itunes:duration');

    // Format date
    const dateObj = new Date(pubDate);
    const formattedDate = isNaN(dateObj.getTime()) ? pubDate : dateObj.toLocaleDateString('en-US', { month: 'long', day: 'numeric', year: 'numeric' });

    // Fetch .md content
    let rawMd = '';
    let transcriptHtml = '';
    let topics: string[] = [];
    let links: { title: string; url: string }[] = [];
    let showNotesHtml = '';

    // Step 1: Fetch dedicated show notes file (all episodes)
    let showNotesMd = '';
    const snUrl = `https://raw.githubusercontent.com/grayking-creator/openclaw-podcast/main/show_notes_episode_${String(episodeNum).padStart(3, '0')}.md`;
    try {
      const snRes = await fetch(snUrl);
      if (snRes.ok) {
        showNotesMd = await snRes.text();
      }
    } catch {
      // no show notes file — graceful fallback
    }

    // Step 2: Fetch transcript — hardcoded filenames per episode number
    const TRANSCRIPT_FILES: Record<number, string> = {
      0: 'episode_000.md',
      1: 'episode_001_full_v2.md',
      2: 'episode_002.md',
      3: 'episode_003.md',
    };
    const transcriptFile = TRANSCRIPT_FILES[episodeNum] ?? `episode_00${episodeNum}.md`;
    const transcriptFetchUrl = `https://raw.githubusercontent.com/grayking-creator/openclaw-podcast/main/${transcriptFile}`;

    try {
      const mdRes = await fetch(transcriptFetchUrl);
      rawMd = await mdRes.text();

      // Step 3: Process fetched markdown
      if (episodeNum === 0) {
        // Extract show notes section from episode_000.md
        if (!showNotesMd) {
          const snMatch = rawMd.match(/^## SHOW NOTES\s*\n([\s\S]*?)(?=^## Full Transcript)/m);
          showNotesMd = snMatch ? snMatch[1].trim() : '';
        }
        // Extract transcript portion only
        const txMatch = rawMd.match(/^## Full Transcript\s*\n([\s\S]*)$/m);
        rawMd = txMatch ? txMatch[1] : rawMd;
      }

      // Render show notes HTML
      if (showNotesMd) {
        showNotesHtml = await marked.parse(showNotesMd);
      } else {
        // Legacy fallback: look for ## SHOW NOTES in transcript
        const showNotesMatch = rawMd.match(/^## SHOW NOTES\s*\n([\s\S]*?)(?=^## )/m);
        if (showNotesMatch) {
          showNotesHtml = await marked.parse(showNotesMatch[1]);
          rawMd = rawMd.replace(/^## SHOW NOTES[\s\S]*?(?=^## )/m, '');
        }
      }

      // Step 4: Extract section headings as topics (always — fallback if no SHOW NOTES)
      topics = [...rawMd.matchAll(/^## SECTION \d+:\s*(.+)$/gm)].map(m => m[1].trim());
      if (!topics.length) {
        topics = [...rawMd.matchAll(/^## (.+)$/gm)]
          .map(m => m[1].trim())
          .filter(t => !t.match(/^(SHOW NOTES|Full Story|Episode)/i));
      }

      // Extract URLs for links section
      const urlMatches = [...rawMd.matchAll(/\[([^\]]+)\]\((https?:\/\/[^)]+)\)/g)];
      links = urlMatches.map(m => ({ title: m[1], url: m[2] }));
      if (!links.length) {
        links = [...rawMd.matchAll(/https?:\/\/[^\s)>\]]+/g)]
          .map(m => {
            try {
              return { title: new URL(m[0]).hostname.replace('www.', ''), url: m[0] };
            } catch {
              return null;
            }
          })
          .filter((l): l is { title: string; url: string } => l !== null)
          .slice(0, 10);
      }

      // Parse markdown → HTML (rawMd already has show notes stripped if needed)
      let html = await marked.parse(rawMd);

      // Style speaker labels
      html = html
        .replace(/\[NOVA\]:/g, '<span class="speaker nova">Nova</span>')
        .replace(/\[ALLOY\]:/g, '<span class="speaker alloy">Alloy</span>')
        .replace(/\*\*Nova:\*\*/g, '<span class="speaker nova">Nova</span>')
        .replace(/\*\*Alloy:\*\*/g, '<span class="speaker alloy">Alloy</span>');

      transcriptHtml = html;
    } catch (e) {
      transcriptHtml = '<p class="text-neutral-500">Transcript unavailable.</p>';
    }

    const coverImage = `/images/podcast/episode_${String(episodeNum).padStart(3, '0')}_cover.png`;

    return {
      params: { slug },
      props: {
        episode: {
          slug,
          number: episodeNum,
          title,
          description,
          date: formattedDate,
          duration,
          audioUrl,
          mdUrl,
          coverImage,
          topics,
          links,
          showNotesHtml,
          transcriptHtml,
        }
      }
    };
  }));

  return episodes;
}

const { episode } = Astro.props;
---

<Layout title={`Episode ${episode.number}: ${episode.title} | OpenClaw Daily`} description={episode.description}>
  <EpisodeDetail episode={episode} client:load />
  <StickySubscribeBar client:load />
</Layout>

<style is:global>
  .speaker {
    font-weight: 700;
    font-size: 0.7rem;
    text-transform: uppercase;
    letter-spacing: 0.1em;
    margin-right: 0.5rem;
  }
  .speaker.nova { color: #60a5fa; } /* blue-400 */
  .speaker.alloy { color: #c084fc; } /* purple-400 */
</style>
