---
import { marked } from 'marked';
import Layout from '../../layouts/Layout.astro';
import EpisodeDetail from '../../components/EpisodeDetail.jsx';
import StickySubscribeBar from '../../components/StickySubscribeBar.jsx';

export async function getStaticPaths() {
  // 1. Fetch RSS
  const rssRes = await fetch('https://grayking-creator.github.io/openclaw-podcast/feed.xml');
  const rssText = await rssRes.text();

  // 2. Parse episodes (same helpers as podcasts.astro ‚Äî inlined here)
  const getTag = (xml: string, tag: string): string => {
    // Handle CDATA
    const cdataRe = new RegExp(`<${tag}[^>]*><!\\[CDATA\\[([\\s\\S]*?)\\]\\]><\\/${tag}>`, 'i');
    const cdataM = xml.match(cdataRe);
    if (cdataM) return cdataM[1].trim();
    const plainRe = new RegExp(`<${tag}[^>]*>([\\s\\S]*?)<\\/${tag}>`, 'i');
    const plainM = xml.match(plainRe);
    return plainM ? plainM[1].trim() : '';
  };

  const getAttr = (xml: string, tag: string, attr: string): string => {
    const re = new RegExp(`<${tag}[^>]*\\s${attr}="([^"]+)"`, 'i');
    const m = xml.match(re);
    return m ? m[1] : '';
  };

  const items = rssText.match(/<item>([\s\S]*?)<\/item>/g) ?? [];

  const episodes = await Promise.all(items.map(async (item) => {
    const episodeNum = parseInt(getTag(item, 'itunes:episode') || '0');
    const slug = `episode-${episodeNum}`;
    const mdUrl = getTag(item, 'link');
    const audioUrl = getAttr(item, 'enclosure', 'url');
    const title = getTag(item, 'title').replace(/^Episode \d+:\s*/, '');
    const description = getTag(item, 'description');
    const pubDate = getTag(item, 'pubDate');
    const duration = getTag(item, 'itunes:duration');

    // Format date
    const dateObj = new Date(pubDate);
    const formattedDate = isNaN(dateObj.getTime()) ? pubDate : dateObj.toLocaleDateString('en-US', { month: 'long', day: 'numeric', year: 'numeric' });

    // Fetch .md content
    let rawMd = '';
    let transcriptHtml = '';
    let topics: string[] = [];
    let links: { title: string; url: string }[] = [];
    let showNotesHtml = '';

    // Step 1: Fetch dedicated show notes file (all episodes)
    let showNotesMd = '';
    const snUrl = `https://raw.githubusercontent.com/grayking-creator/openclaw-podcast/main/show_notes_episode_${String(episodeNum).padStart(3, '0')}.md`;
    try {
      const snRes = await fetch(snUrl);
      if (snRes.ok) {
        showNotesMd = await snRes.text();
      }
    } catch {
      // no show notes file ‚Äî graceful fallback
    }

    // Step 2: Fetch transcript ‚Äî hardcoded filenames per episode number
    const TRANSCRIPT_FILES: Record<number, string> = {
      0: 'episode_000.md',
      1: 'episode_001_full_v2.md',
      2: 'episode_002.md',
      3: 'episode_003.md',
    };
    const transcriptFile = TRANSCRIPT_FILES[episodeNum] ?? `episode_00${episodeNum}.md`;
    const transcriptFetchUrl = `https://raw.githubusercontent.com/grayking-creator/openclaw-podcast/main/${transcriptFile}`;

    try {
      const mdRes = await fetch(transcriptFetchUrl);
      rawMd = await mdRes.text();

      // Step 3: Process fetched markdown
      if (episodeNum === 0) {
        // Extract show notes section from episode_000.md
        if (!showNotesMd) {
          const snMatch = rawMd.match(/^## SHOW NOTES\s*\n([\s\S]*?)(?=^## Full Transcript)/m);
          showNotesMd = snMatch ? snMatch[1].trim() : '';
        }
        // Extract transcript portion only
        const txMatch = rawMd.match(/^## Full Transcript\s*\n([\s\S]*)$/m);
        rawMd = txMatch ? txMatch[1] : rawMd;
      }

      // Render show notes HTML
      if (showNotesMd) {
        showNotesHtml = await marked.parse(showNotesMd);
      } else {
        // Legacy fallback: look for ## SHOW NOTES in transcript
        const showNotesMatch = rawMd.match(/^## SHOW NOTES\s*\n([\s\S]*?)(?=^## )/m);
        if (showNotesMatch) {
          showNotesHtml = await marked.parse(showNotesMatch[1]);
          rawMd = rawMd.replace(/^## SHOW NOTES[\s\S]*?(?=^## )/m, '');
        }
      }

      // Step 4: Extract section headings as topics (always ‚Äî fallback if no SHOW NOTES)
      topics = [...rawMd.matchAll(/^## SECTION \d+:\s*(.+)$/gm)].map(m => m[1].trim());
      if (!topics.length) {
        topics = [...rawMd.matchAll(/^## (.+)$/gm)]
          .map(m => m[1].trim())
          .filter(t => !t.match(/^(SHOW NOTES|Full Story|Episode)/i));
      }

      // Extract URLs for links section
      const urlMatches = [...rawMd.matchAll(/\[([^\]]+)\]\((https?:\/\/[^)]+)\)/g)];
      links = urlMatches.map(m => ({ title: m[1], url: m[2] }));
      if (!links.length) {
        links = [...rawMd.matchAll(/https?:\/\/[^\s)>\]]+/g)]
          .map(m => {
            try {
              return { title: new URL(m[0]).hostname.replace('www.', ''), url: m[0] };
            } catch {
              return null;
            }
          })
          .filter((l): l is { title: string; url: string } => l !== null)
          .slice(0, 10);
      }

      // Parse markdown ‚Üí HTML (rawMd already has show notes stripped if needed)
      let html = await marked.parse(rawMd);

      // Style speaker labels
      html = html
        .replace(/\[NOVA\]:/g, '<span class="speaker nova">Nova</span>')
        .replace(/\[ALLOY\]:/g, '<span class="speaker alloy">Alloy</span>')
        .replace(/\*\*Nova:\*\*/g, '<span class="speaker nova">Nova</span>')
        .replace(/\*\*Alloy:\*\*/g, '<span class="speaker alloy">Alloy</span>');

      transcriptHtml = html;
    } catch (e) {
      transcriptHtml = '<p class="text-neutral-500">Transcript unavailable.</p>';
    }

    const coverImage = `/images/podcast/episode_${String(episodeNum).padStart(3, '0')}_cover.png`;

    return {
      params: { slug },
      props: {
        episode: {
          slug,
          number: episodeNum,
          title,
          description,
          date: formattedDate,
          duration,
          audioUrl,
          mdUrl,
          coverImage,
          topics,
          links,
          showNotesHtml,
          transcriptHtml,
        }
      }
    };
  }));

  // TOFT episodes from Anchor RSS
  const toftEpisodes: any[] = [];
  try {
    const toftRes = await fetch('https://anchor.fm/s/108bc95a4/podcast/rss');
    const toftXml = await toftRes.text();
    const toftItems = toftXml.match(/<item>([\s\S]*?)<\/item>/g) ?? [];
    toftItems.forEach((item, idx) => {
      const index = idx + 1;
      const slug = `toft-${index}`;
      const title = getTag(item, 'title');
      const rawDesc = getTag(item, 'description');
      const showNotesHtml = rawDesc
        .replace(/&amp;/g, '&').replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&quot;/g, '"').replace(/&#39;/g, "'");
      const description = rawDesc.replace(/<[^>]+>/g, ' ').replace(/\s+/g, ' ').trim().slice(0, 300);
      const pubDateRaw = getTag(item, 'pubDate');
      const dateObj = new Date(pubDateRaw);
      const date = isNaN(dateObj.getTime()) ? pubDateRaw : dateObj.toLocaleDateString('en-US', { month: 'long', day: 'numeric', year: 'numeric' });
      const audioUrl = (() => { const re = /<enclosure[^>]*\surl="([^"]+)"/i; const m = item.match(re); return m ? m[1] : ''; })();
      const duration = getTag(item, 'itunes:duration');
      toftEpisodes.push({
        params: { slug },
        props: {
          episode: {
            slug, isToft: true, index, title, description, date, duration, audioUrl,
            coverImage: 'https://d3t3ozftmdmh3i.cloudfront.net/staging/podcast_uploaded_nologo/44315441/44315441-1769259381156-db3a704d94734.jpg',
            showNotesHtml,
            transcriptHtml: '<p class="text-neutral-500 italic">Transcript not available for this episode.</p>',
          }
        }
      });
    });
  } catch (e) { /* Anchor RSS unavailable */ }

  return [...episodes, ...toftEpisodes];
}

const { episode } = Astro.props;
---

<Layout title={episode.isToft ? `${episode.title} | Toby on Fitness Tech` : `Episode ${episode.number}: ${episode.title} | OpenClaw Daily`} description={episode.description}>
  {episode.isToft ? (
    <div class="max-w-3xl mx-auto px-4 py-12">
      <a href="/podcasts/" class="text-blue-400 text-sm hover:underline mb-6 inline-block">‚Üê Back to Podcasts</a>
      <div class="bg-neutral-900 border border-neutral-800 rounded-2xl p-8">
        <div class="flex gap-4 mb-6">
          <img src={episode.coverImage} alt="Toby on Fitness Tech" class="w-24 h-24 rounded-xl object-cover border border-neutral-700 shrink-0" />
          <div>
            <span class="bg-green-400/10 text-green-400 text-xs font-bold px-2 py-0.5 rounded-full inline-block mb-2">üí™ Fitness Tech</span>
            <h1 class="text-2xl font-bold text-white">{episode.title}</h1>
            <p class="text-neutral-500 text-sm mt-1">{episode.date}{episode.duration ? ` ¬∑ ‚è± ${episode.duration}` : ''}</p>
          </div>
        </div>
        <audio controls class="w-full mb-8 rounded-xl" src={episode.audioUrl}></audio>
        <div class="mb-8">
          <h2 class="text-lg font-bold text-white mb-3">üìÑ Show Notes</h2>
          <div class="text-neutral-300 text-sm leading-relaxed prose prose-invert max-w-none" set:html={episode.showNotesHtml} />
        </div>
        <div>
          <h2 class="text-lg font-bold text-white mb-3">üìù Transcript</h2>
          <div class="text-neutral-400 text-sm" set:html={episode.transcriptHtml} />
        </div>
      </div>
    </div>
  ) : (
    <EpisodeDetail episode={episode} client:load />
  )}
  <StickySubscribeBar client:load />
</Layout>

<style is:global>
  .speaker {
    font-weight: 700;
    font-size: 0.7rem;
    text-transform: uppercase;
    letter-spacing: 0.1em;
    margin-right: 0.5rem;
  }
  .speaker.nova { color: #60a5fa; } /* blue-400 */
  .speaker.alloy { color: #c084fc; } /* purple-400 */
</style>
